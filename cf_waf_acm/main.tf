// This Terraform template sets up a CloudFront distribution between a "human-friendly" domain (e.g., "terraform-test-bucket.com") and 
// an origin (e.g., "http://this-is-a-very-lengthy-url.s3-website-us-east-1.amazonaws.com").
//
// ACM is used for HTTPS certificate management. The cert is attached to the CloudFront distribution.
// Route53 is used for DNS. The hosted zone points to the CloudFront distribution.
// waf.tf sets up a basic WAF rate limiting rule, which is attached to the CloudFront distribution via a WAF ACL containing the rule.
// S3 is used for CloudFront logs.
// KMS is used to encrypt the S3 log bucket.
//
// More info: https://www.terraform.io/docs/providers/aws/r/cloudfront_distribution.html#example-usage

// Use an S3 bucket to store the Terraform state, as the Docker image or other build/plan/apply instance may be ephemeral
// At present, the Terraform state bucket must be created before executing this Terraform recipe

// ACM certs for CloudFront must be created in US East 1 at the time of writing
provider "aws" {
  #alias  = "acm_region"
  region = var.region #"us-east-1"
}

// At present, the domain name must be attached to a Route53 Zone, e.g. it must have been registered through AWS
data "aws_route53_zone" "root" {
  name = "${var.domain_name}."
}

locals {
  log_bucket_prefix = substr(replace(var.domain_name, ".", "-"), 0, 36)
  domains_list      = var.use_root_domain ? concat([var.domain_name], var.alternate_domains) : var.alternate_domains
  validation_domains = var.acm_certificate_arn == "" ? distinct(
    [for k, v in aws_acm_certificate.cert[0].domain_validation_options : merge(
      tomap(v), { domain_name = replace(v.domain_name, "*.", "") }
    )]
  ) : []
}

// Generate a KMS key for encryption of the log bucket
resource "aws_kms_key" "log_bucket_key" {
  description         = "Auto-generated key for encrypting/decrypting the contents of the ${local.log_bucket_prefix}_logs S3 bucket"
  enable_key_rotation = true
}

// Create a bucket for logs generated by the CloudFront distribution

#tfsec:ignore:AWS002 tfsec:ignore:AWS017
resource "aws_s3_bucket" "cloudfront_log_bucket" {
  // The bucket is named after the apex / root domain name; AWS automagically adds a random suffix to this prefix to ensure uniqueness.
  bucket_prefix = local.log_bucket_prefix
}

resource "aws_s3_bucket_acl" "cloudfront_log_bucket_acl" {
  bucket = aws_s3_bucket.cloudfront_log_bucket.id
  acl    = "private"
}

resource "aws_s3_bucket_lifecycle_configuration" "move_to_glacier_after_30_days" {
  bucket = aws_s3_bucket.cloudfront_log_bucket.id
  // Move to Glacier after 30 days
  rule {
    status = "Enabled"
    id     = "Move to Glacier after 30 days"
    transition {
      days          = 30
      storage_class = "GLACIER"
    }
    expiration {
      days = 90
    }
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "cloudfront_log_bucket_sse_kms" {
  bucket = aws_s3_bucket.cloudfront_log_bucket.id
  // Encrypt the logs using KMS
  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm     = "aws:kms"
      kms_master_key_id = aws_kms_key.log_bucket_key.id
    }
  }
}

#tfsec:ignore:aws-s3-ignore-public-acls tfsec:ignore:aws-s3-no-public-buckets
resource "aws_s3_bucket_public_access_block" "cloudfront_log_bucket_access_block" {
  bucket = aws_s3_bucket.cloudfront_log_bucket.id

  block_public_acls   = true
  block_public_policy = true
  ignore_public_acls  = false
}

// Provision an ACM cert if one hasn't been supplied
resource "aws_acm_certificate" "cert" {
  count = var.acm_certificate_arn == "" ? 1 : 0

  domain_name               = var.domain_name
  validation_method         = "DNS"
  subject_alternative_names = var.alternate_domains
  lifecycle {
    create_before_destroy = true
  }
  #provider = aws.acm_region
}

// Validate the cert for the root domain before proceeding to use it for CloudFront HTTPS traffic
resource "aws_route53_record" "cert_validation" {
  count = var.acm_certificate_arn == "" ? length(concat([var.domain_name], var.alternate_domains)) : 0

  zone_id = data.aws_route53_zone.root.zone_id
  name    = element(local.validation_domains, count.index)["resource_record_name"]
  type    = element(local.validation_domains, count.index)["resource_record_type"]
  ttl     = 60

  records = [
    element(local.validation_domains, count.index)["resource_record_value"]
  ]

  allow_overwrite = true
}

// The validation itself is a resource we can reference
// Waiting on the validation to exist, then referencing the validation instead of the cert, ensures that the cert is valid before we ever use it
resource "aws_acm_certificate_validation" "result" {
  count = var.acm_certificate_arn == "" ? 1 : 0

  certificate_arn = aws_acm_certificate.cert[0].arn
  validation_record_fqdns = [
    for record in aws_route53_record.cert_validation : record.fqdn
  ]

  // If this takes more than 5 minutes, something is probably wrong. Set to 15 minutes to allow for leeway. Default is 45 minutes.
  timeouts {
    create = "15m"
  }
}

// Conditionally create a WAF based on the preferred version. By default, WAFv2 will be used, but the rate-limited WAFv1 is available if
// the requirements call for it.
module "waf_rate_limited" {
  count  = var.use_wafv2 ? 0 : 1
  source = "../waf_rate_limit_2000"
}

module "wafv2" {
  count  = var.use_wafv2 ? 1 : 0
  source = "../wafv2"

  name  = "${local.log_bucket_prefix}_acl" # WAF names have similar restrictions to bucket names.
  scope = "CLOUDFRONT"

  ip_rate_based_rule = {
    name : "rate_limit_all_rule"
    priority : 1
    action : "block"
    limit : var.rate_limit
  }
}

// Provision the CloudFront distribution
// Note that this step typically takes 15 minutes or more, e.g.:
// > aws_cloudfront_distribution.distribution: Creation complete after 23m42s [id=E25IP7Y7CE1Y8K]
#tfsec:ignore:aws-cloudfront-use-secure-tls-policy
resource "aws_cloudfront_distribution" "distribution" {
  // "origin" is AWS-speak for "target URL", i.e. what's behind Cloudfront and will be cached in the CloudFront distribution
  origin {
    // Note that if the origin is an S3 bucket, the bucket MUST NOT be set up as a static web site!
    // Use the custom origin config + disable direct serving of assets; instead, use an OAI and only allow CloudFront to serve the bucket's objects.
    custom_origin_config {
      http_port              = var.http_port
      https_port             = var.https_port
      origin_protocol_policy = var.origin_protocol_policy
      origin_ssl_protocols   = var.origin_ssl_protocols
    }

    // The origin URL
    domain_name = var.target_origin
    // This is just an arbitrary "tag" or "nickname"; that said, using the URL here reminds one of the URL redirect
    origin_id = var.domain_name
  }

  // For web sites behind CloudFront distributions, use "index.html", especially if the origin is a static page on S3
  default_root_object = var.origin_root_object

  // Log to the S3 bucket created earlier; logs are specific to this distribution
  logging_config {
    include_cookies = false
    bucket          = aws_s3_bucket.cloudfront_log_bucket.bucket_domain_name
    prefix          = "${var.domain_name}_cloudfront_logs"
  }

  // All values are defaults from the AWS console:
  default_cache_behavior {
    // HTTPS only!
    viewer_protocol_policy = "redirect-to-https"
    compress               = var.compress_content
    allowed_methods        = var.allowed_http_methods
    cached_methods         = var.cached_http_methods
    // This must match the "origin_id" value under "resource: origin: origin_id" above
    target_origin_id = var.domain_name
    min_ttl          = var.min_ttl
    default_ttl      = var.default_ttl
    max_ttl          = var.max_ttl

    forwarded_values {
      query_string = false
      cookies {
        forward = "none"
      }
    }
  }

  // Include all CNAME values for which SNI should apply. See https://en.wikipedia.org/wiki/Server_Name_Indication
  aliases = local.domains_list #concat([var.domain_name],var.alternate_domains)

  // Use an ACM cert for SSL/TLS
  viewer_certificate {
    // Use the ARN of the validated ACM cert
    acm_certificate_arn = var.acm_certificate_arn == "" ? aws_acm_certificate_validation.result[0].certificate_arn : var.acm_certificate_arn
    // SNI is better than wildcard certs. See https://en.wikipedia.org/wiki/Server_Name_Indication
    ssl_support_method = "sni-only"
    // See "origin_ssl_protocols"
    minimum_protocol_version = "TLSv1.2_2018"
  }

  restrictions {
    geo_restriction {
      restriction_type = length(var.georestriction_countries) == 0 ? "none" : var.georestriction_type
      locations        = var.georestriction_countries
    }
  }

  web_acl_id = var.use_wafv2 ? module.wafv2[0].web_acl_id : module.waf_rate_limited[0].acl_id

  enabled = true
}
